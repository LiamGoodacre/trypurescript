-----------------------------------------------------------------------------
--
-- Module      :  Main
-- Copyright   :  (c) Phil Freeman 2013-2015
-- License     :  MIT
--
-- Maintainer  :  paf31@cantab.net
-- Stability   :
-- Portability :
--
-- |
--
-----------------------------------------------------------------------------

{-# LANGUAGE DataKinds, OverloadedStrings, TemplateHaskell #-}

module Main (
    main
) where

import qualified Language.PureScript as P

import Data.Version (showVersion)
import Data.Monoid
import Data.String
import Data.Maybe (mapMaybe)
import Data.List (intercalate)
import Data.FileEmbed

import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC8
import qualified Data.ByteString.Lazy.Char8 as BLC8

import qualified Data.Map as M

import Control.Applicative
import Control.Monad (when, forM_)
import Control.Monad.Trans
import Control.Monad.Reader

import Network.HTTP.Types (status500)

import Web.Scotty
import qualified Web.Scotty as Scotty

import Text.Blaze.Html
import Text.Blaze.Internal
import Text.Blaze.Html.Renderer.Text
import qualified Text.Blaze.Html5 as H
import qualified Text.Blaze.Html5.Attributes as A

import qualified Paths_trypurescript as Paths

import System.Environment (getArgs)

data Compiled = Compiled { js      :: String
                         , externs :: String
                         }

newtype Response = Response { runResponse :: Either String Compiled }

options :: P.Options P.Compile
options = P.defaultCompileOptions 
            { P.optionsAdditional = P.CompileOptions "PS" [] []
            , P.optionsMain = Just "Main"
            }

compile :: [P.Module] -> String -> IO Response
compile _ input | length input > 20000 = return $ Response $ Left "Please limit your input to 20000 characters"
compile prelude input = do
  case either Left (Right . map snd) $ P.parseModulesFromFiles (const "<file>") [(undefined, input)] of
    Left parseError -> do
      return $ Response $ Left $ show parseError
    Right modules -> do
      case flip runReaderT options $ P.compile (prelude ++ modules) ["Generated by trypurescript"] of
        Left error ->
          return $ Response $ Left error
        Right (js, externs, _) ->
          return $ Response $ Right $ Compiled js externs

str :: String -> String
str = id

mono :: H.Html -> H.Html
mono h = h ! A.class_ "mono"

css :: String
css = BC8.unpack $(embedFile "assets/style.css")

gaq :: String
gaq = BC8.unpack $(embedFile "assets/gaq.js")

scripts :: String
scripts = BC8.unpack $(embedFile "assets/scripts.js")

defaultCode :: String
defaultCode = BC8.unpack $(embedFile "examples/default.purs")

examples :: [(String, (String, String))]
examples =
  [ ("adt",         ("Algebraic Data Types",  BC8.unpack $(embedFile "examples/adt.purs")))
  , ("ops",         ("Operators",             BC8.unpack $(embedFile "examples/operators.purs")))
  , ("arrays",      ("Arrays",                BC8.unpack $(embedFile "examples/arrays.purs")))
  , ("rows",        ("Row Polymorphism",      BC8.unpack $(embedFile "examples/rows.purs")))
  , ("ffi",         ("FFI",                   BC8.unpack $(embedFile "examples/ffi.purs")))
  , ("mutable",     ("Mutable Variables",     BC8.unpack $(embedFile "examples/mutable.purs")))
  , ("recursion",   ("Recursion",             BC8.unpack $(embedFile "examples/recursion.purs")))
  , ("do",          ("Do Notation",           BC8.unpack $(embedFile "examples/do.purs")))
  , ("tco",         ("Tail-Call Elimination", BC8.unpack $(embedFile "examples/tco.purs")))
  , ("typeclasses", ("Type Classes",          BC8.unpack $(embedFile "examples/typeclasses.purs")))
  ]

page :: String -> ActionM ()
page input = html $ renderHtml $ do
  H.docType
  H.html $ do
    H.head $ do
      H.title $ H.toHtml $ str "Try PureScript!"
      H.meta ! A.name "viewport" ! A.content "width=device-width, initial-scale=1.0"
      H.link ! A.rel "stylesheet" ! A.type_ "text/css" ! A.href "http://fonts.googleapis.com/css?family=Roboto:300,600"
      H.style $ H.toHtml $ str css
      H.script ! A.type_ "text/javascript" $ preEscapedToHtml gaq
      H.script ! A.type_ "text/javascript" ! A.src "//cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.js" $ mempty
      H.script ! A.type_ "text/javascript" ! A.src "//cdnjs.cloudflare.com/ajax/libs/ace/1.1.01/ace.js" ! A.charset "utf-8" $ mempty
      H.script ! A.type_ "text/javascript" ! A.src "//cdnjs.cloudflare.com/ajax/libs/ace/1.1.01/mode-haskell.js" $ mempty
      H.script ! A.type_ "text/javascript" ! A.src "//cdnjs.cloudflare.com/ajax/libs/ace/1.1.01/theme-dawn.js" $ mempty
    H.body $ do
        H.a ! A.href "https://github.com/purescript" $
            H.img ! A.style "position: absolute; top: 0; right: 0; border: 0;"
                  ! A.src "https://github-camo.global.ssl.fastly.net/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"
                  ! A.alt "Fork me on GitHub"
                  ! customAttribute "data-canonical-src" "https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
        H.div ! A.class_ "wrapper" $ do
           H.div ! A.class_ "header" $ do
               H.h1 $ H.toHtml $ str "Try PureScript!"
           H.div ! A.class_ "body" $ do
               H.p $ H.toHtml $ str "Type PureScript code below and press 'Compile', or select one of the examples below:"
        
               H.h2 $ H.toHtml $ str "Examples"
               H.ul $ do
                 forM_ examples $ \(name, (title, _)) ->
                   H.li $ H.a ! A.href (fromString $ "/example/" ++ name) $ H.toHtml title
        
               H.h2 $ H.toHtml $ str "PureScript Code"
               H.div ! A.id "code" $ mempty
               H.textarea ! A.name "code" ! A.id "textarea" ! A.style "display: none;" $ H.toHtml $ str input
               H.p $ H.button ! A.id "compile" $ H.toHtml $ str "Compile and Run"
               H.script ! A.type_ "text/javascript" $ preEscapedToHtml scripts
               H.div ! A.id "results" $ mempty

server :: Int -> IO ()
server port = do
  let preludeModules = either (error . show) (map snd) $ P.parseModulesFromFiles (const "<prelude>") [(undefined, P.prelude)]
  scotty port $ do
    get "/" $ do
      page defaultCode
    get "/example/:name" $ do
      name <- param "name"
      case lookup name examples of
        Nothing -> raise "No such example"
        Just (_, code) -> do
          page code
    post "/compile/text" $ do
      code <- BLC8.unpack <$> body
      response <- lift $ compile preludeModules code
      case runResponse response of
        Left err -> do
          status status500
          Scotty.text . fromString $ err
        Right comp -> 
          Scotty.text . fromString $ js comp

main :: IO ()
main = do
  [port] <- getArgs
  server (read port)
